#!/usr/bin/perl -w 

############ SUB ROUTINES START ###############

sub check_flags {
    my (@argvs) = @_;
    my @new_argvs;

    foreach $item (@argvs){
        if ($item =~ /^\-\-/){
            die ("usage: sped [-i] [-n] [-f <script-file] [sed-command] <files>\n");
        }

        if ($item =~ /^\-/){
            if ($item eq "-i"){
                $i_flag = 1;
            }
            elsif ($item eq "-f"){
                $f_flag = 1;
            }
            elsif ($item eq "n"){
                $n_flag = 1;
            }
            else{
                die ("usage: sped [-i] [-n] [-f <script-file] [sed-command] <files>\n");
            }
        }
        else{
            push (@new_argvs,$item);
        }

    }

    return (@new_argvs);
}

# Remove the heading and trailing commas;
sub chomp_comma {
    my ($addr) = @_;
    my $addr_len = length($addr);
    @chars = split(//,$addr);
    my $start = 0;
    my $end = 0;
    for my $i (0..$addr_len-1){
        my $ch = $chars[$i];
        if ($ch ne ';'){
            $start = $i;
            last;
        }
    }
    for (my $i=$addr_len-1;$i>=0;$i-=1){
        my $ch = $chars[$i];
        if ($ch ne ';'){
            $end = $i +1;
            last;
        }
    }
    return (substr($addr,$start,$end));
}

sub get_commands {
    my ($addr) = @_;
    $addr = chomp_comma($addr);
    my @commands;
    my $addr_len = length($addr);
    my @chars = split(//,$addr);
    $anchor = 0;
    for ($i=1;$i<$addr_len;$i=$i+1){
        my $ch = $chars[$i];
        if ($ch eq ';'){
            my $prev_ch = $chars[$i-1];
            if ($prev_ch eq '/'){
                next;
            }
            my $str = substr($addr,$anchor,$i);
            push(@commands,$str);
            $anchor = $i +1;
        }
    }
    my $str = substr($addr,$anchor,$addr_len);
    push(@commands,$str);
    return @commands;
}

sub get_command_type {
    my ($cmd) = @_;

    if ($cmd =~ /d$/){
        return ("d");
    }
    elsif ($cmd =~ /q$/){
        return ("q");
    }
    elsif ($cmd =~ /p$/){
        return ("p");
    }
    elsif ($cmd =~ /^s/){
        return ("s");
    }
    else{
        return ("default");
    }
}

sub rm_space {
    my ($cmd) = @_;
    $cmd_len = length($cmd);
    my @chars = split(//,$cmd);
    my @new_chars;

    for (my $i =0; $i < $cmd_len;$i=$i+1){
        my $ch = $chars[$i];
        if ($ch ne ' '){
            push(@new_chars,$ch);
        }
    }
    my $new_cmd = join("",@new_chars);
    return ($new_cmd);
}

sub rm_comment {
    my ($cmd) = @_;
    $cmd_len = length($cmd);
    my @chars = split(//,$cmd);
    my @new_chars;

    for (my $i =0; $i < $cmd_len;$i=$i+1){
        my $ch = $chars[$i];
        if ($ch ne '#'){
            push(@new_chars,$ch);
        }
        else{
            last;
        }
    }
    my $new_cmd = join("",@new_chars);
    return ($new_cmd);
}

sub commands_with_type {
    my (@cmds) = @_;
    my @new_cmds;
    foreach $cmd (@cmds){
        $cmd = rm_space($cmd);
        $cmd = rm_comment($cmd);
        $type = get_command_type($cmd);
        @item = ($cmd,$type);
        push(@new_cmds,\@item);
    }
    return (@new_cmds);
}

sub exec_cmd {
    my ($item,$line) = @_;
    $cmd = $item -> [0];
    $type = $item -> [1];

    if ($type eq "q"){
        &q_command($cmd,$line);
    }
    elsif ($type eq "p"){
        &p_command($cmd,$line);
    }
    elsif ($type eq "d"){
        &d_command($cmd,$line);
    }
    # TODO: D_COMMAND, P_COMMAND ETC.
    return ($line);
}

sub q_command {
    my ($cmd,$line) = @_;
    if ($cmd =~ /^(\d+)q$/){
        if ($1 == $LINE_NUM){
            $EXIT_STATUS = 1;
        }
    }
    elsif ($cmd =~ /^\/(.*)\/q$/){
        if ($line =~ /$1/){
            $EXIT_STATUS = 1;
        }
    }
    else{
        die("sped: command line: invalid command");
    }
}

sub p_command {
    my ($cmd,$line) = @_;
    if ($cmd =~ /^(\d+)p$/){
        if ($1 == $LINE_NUM){
            print("$line\n");
        }
    }
    elsif ($cmd =~ /^\/(.*)\/p$/){
        if ($line =~ /$1/){
            print("$line\n");
        }
    }
    else{
        die("sped: command line: invalid command");
    }
}

sub d_command {
    my ($cmd,$line) = @_;
    if ($cmd =~ /^(\d+)d$/){
        if ($1 == $LINE_NUM){
            $DELETE_STATUS = 1;
        }
    }
    elsif ($cmd =~ /^\/(.*)\/d$/){
        if ($line =~ /$1/){
            $DELETE_STATUS = 1;
        }
    }
    else{
        die("sped: command line: invalid command");
    }
}

############ SUB ROUTINES ENDS ################
our $i_flag = 0;
our $f_flag = 0;
our $n_flag = 0;
our @argvs = check_flags(@ARGV);

our $EXIT_STATUS = 0;
our $DELETE_STATUS = 0;

our $sed_commands = chomp_comma($argvs[0]);
our @commands = get_commands($sed_commands); 
@commands = commands_with_type(@commands);

our $LINE_NUM = 1;

while ($line = <STDIN>){
    chomp $line;

    foreach $item (@commands){
        $EXIT_STATUS = 0;
        $DELETE_STATUS = 0;
        &exec_cmd($item,$line);
    }

    if ($n_flag == 0 && $DELETE_STATUS == 0){
        print("$line\n");
    }
    
    if ($EXIT_STATUS == 1){
        exit 0;
    }
    $LINE_NUM +=1;
}

